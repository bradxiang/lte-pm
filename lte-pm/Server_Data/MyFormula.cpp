#include "StdAfx.h"
#include "MyFormula.h"
//#include "RT-SPAA.h"


//------------------------------------------------------------------------------------------------------
//	构造函数
//------------------------------------------------------------------------------------------------------
CMyFormula::CMyFormula(void)
{
}

//------------------------------------------------------------------------------------------------------
//	析构函数
//------------------------------------------------------------------------------------------------------
CMyFormula::~CMyFormula(void)
{
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
void CMyFormula::replacesign(char *os,char *ts)//替换表达式中的特定变量
{
	char temp[5][32]={};
	char m[32]={"  0.57000"};//M值的替换输入值
	char v[5][32] = {"  0.65000","1.5","3.2","8.5","5.4"};//V的替换值
	int vx[9];

	int i,j,k,vn;
	i = 0;
	j = 0;
	k = 0;

	while(os[i] != '\0'){
		if (os[i] != 'M')
			temp[j][k++] = os[i++];
		else{
			j++;
			k = 0;
			i++;
		}
	}
	strcpy(ts,temp[0]);//cstrcpy,cstrcat....
	if (j > 0){
		strcat(ts,m);//ftoa?
		strcat(ts,temp[1]);
	}// 完成对m值的替换

	strcpy(os,ts);//cstrcpy,cstrcat....

	i = 0;
	j = 0;
	k = 0;
	vn = 0; //记录vx个数
	memset(temp,0,sizeof(temp));

	while(os[i] != '\0'){
		if (os[i] != 'V')
			temp[j][k++] = os[i++];
		else{
			j++;
			k = 0;
			i++;
			vx[vn++] = os[i++] - '0';

		}
	}
	strcpy(ts,temp[0]);//cstrcpy,cstrcat....
	if (j > 0){
		for( i = 1; i < j + 1; i ++){
			strcat(ts,v[vx[i-1]-1]);//ftoa?
			strcat(ts,temp[i]);
		}
	}// 完成对m值的替换

//	printf("The final formula is %s\n",ts);
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
float CMyFormula::simcalc(char *os)//计算字符型表达式
{
	int type, sign;
	float op1, op2;
	char s[MAXOP];

	sp_d = 0;
	/* a stack for sign */
	sp_s = 0;
	bufp = 0;
	j = 0;

	while ((type = getop(os,s)) != EOF) {//Ctrl+Z可以输入EOF
		switch (type) {
				case NUMBER:
					push_d(atof(s));
					break;
				case '(':
					push_s(type);
					break;
				case '+':
				case '-':
				case '*':
				case '/':
					//				case '^':
					while (cmp(sign = pop_s(),type) >= 0) {
						op2 = pop_d();
						op1 = pop_d();
						int i = push_d(calc(sign, op1, op2));
						if (i == -1)
						{
							return -1;
						}
					}
					push_s(sign);
					push_s(type);
					break;
				case ')':
					while((sign = pop_s()) != '(') {
						op2 = pop_d();
						op1 = pop_d();
						int i = push_d(calc(sign, op1, op2));
						if (i == -1)
						{
							return -1;
						}
					}
					break;

				case '=':
					break;
				case '\0':
					while((sign = pop_s()) != EOF) {
						op2 = pop_d();
						op1 = pop_d();
						int i = push_d(calc(sign, op1, op2));
						if (i == -1)
						{
							return -1;
						}
					}
					return  pop_d();
		}
	}

}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
float CMyFormula::calc(int sign, float op1, float op2)
{
	switch (sign) {
		case '+':
			return op1 + op2;
			break;
		case '*':
			return op1 * op2;
			break;
		case '-':
			return op1 - op2;
			break;
		case '/':
			if (op2 != 0)
				return op1 / op2;
			else
				return -1.0;
				//printf("error: zero divisor\n");
			break;
			//       case '^':
			//               return pow(op1, op2);
			//               break;
		default:
			break;
	}
	return 0.0;
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::cmp(int s1, int s2)
{
	int s[2],i;

	s[0] = s1;
	s[1] = s2;
	for (i = 0; i < 2; i++) {
		switch (s[i]) {
				case EOF:
					s[i] = 0;
					break;
				case '(':
					s[i] = 0;
					break;
				case '+':
					s[i] = 1;
					break;
				case '-':
					s[i] = 1;
					break;
				case '*':
					s[i] = 2;
					break;
				case '/':
					s[i] = 2;
					break;
					//               case '^':
					//                       s[i] = 3;
					//                       break;
				default:
					printf("error:unknown comand\n");
					return 10;
		}
	}
	return s[0] - s[1];
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::push_d(float f)
{
	if (sp_d < MAXVAL && f != -1.0)
	{
		val_d[sp_d++] = f;
		return 1;
	}
	else
	{
		printf("error: stack full, can't push %g\n", f);
		return -1;
	}
		
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
float CMyFormula::pop_d(void)
{
	if (sp_d > 0)
		return val_d[--sp_d];
	else {
		printf("error: stack empty\n");
		return 0.0;
	}
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
void CMyFormula::push_s(int c)
{
	if (sp_s < MAXVAL)
		val_s[sp_s++] = c;
	else
		printf("error: stack full, can't push %c\n", c);
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::pop_s(void)
{
	if (sp_s > 0)
		return val_s[--sp_s];
	else 
		return EOF;
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::getop(char *os,char *s)
{
	int i, c;

	while ((s[0] = c = getch(os)) == ' ' || c == '\t');
	s[1] = '\0';
	if (!isdigit(c) && c != '.')
		return c;
	i = 0;
	if (isdigit(c))
		while (isdigit(s[++i] = c = getch(os)));
	if (c == '.')
		while (isdigit(s[++i] = c = getch(os)));
	s[i] = '\0';
	if (c != EOF)
		ungetch(c);
	return NUMBER;
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::getch(char *os)
{
	return (bufp > 0) ? buf[--bufp] : os[j++];
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
void CMyFormula::ungetch(int c)
{
	if (bufp >= BUFSIZE)
		printf("ungetch: too many characters\n");
	else
		buf[bufp++] = c;
}

//------------------------------------------------------------------------------------------------------
//	功能函数：
//------------------------------------------------------------------------------------------------------
int CMyFormula::isdigit( int ch )

{
	return (unsigned int)(ch - '0') < 10u;

}//判断字符ch是否为数字


//------------------------------------------------------------------------------------------------------
//	End
//------------------------------------------------------------------------------------------------------
